#!/usr/bin/env python3
"""
aggregate_engagement.py

This module provides functions to:
  - Load a student roster (one name per line) from a file (path or file-like object).
  - Aggregate engagement metrics from a CSV file (generated by zoom_parser.py) for each student.
  - Write the aggregated metrics to a CSV file.

Usage (as an importable module):
    from aggregate_engagement import aggregate_engagement, write_aggregate_to_csv, load_roster
"""

import csv

def read_text(input_data):
    """
    Read text from a file path or file-like object.
    """
    if hasattr(input_data, "read"):
        content = input_data.read()
        if isinstance(content, bytes):
            content = content.decode("utf-8")
        return content
    else:
        with open(input_data, "r", encoding="utf-8") as f:
            return f.read()


def load_roster(input_data):
    """
    Load the roster of student names (one per line).
    
    input_data can be a file path or file-like object.
    Returns a set of student names.
    """
    content = read_text(input_data)
    students = set()
    for line in content.splitlines():
        name = line.strip()
        if name:
            students.add(name)
    return students


def aggregate_engagement(input_csv, roster_input):
    """
    Read the parsed CSV (from zoom_parser.py) and aggregate engagement metrics for each student.
    
    Parameters:
      input_csv: file path or file-like object for the parsed CSV.
      roster_input: file path or file-like object for the roster.
      
    Returns:
      (student_stats, categories) where student_stats is a dict mapping student names to metrics.
    """
    # Expected categories.
    categories = ["environment", "community", "personal", "wonder", "tinker", "identity", "disruption"]
    roster_set = load_roster(roster_input)
    # Initialize stats for each student.
    student_stats = {student: {"total_messages": 0, "lesson_relevancy_sum": 0.0, "relevancy_count": 0} for student in roster_set}
    for student in student_stats:
        for cat in categories:
            student_stats[student][cat] = 0
    # Read CSV content.
    csv_content = read_text(input_csv)
    reader = csv.DictReader(csv_content.splitlines())
    for row in reader:
        speaker = row.get("speaker", "").strip()
        if speaker in student_stats:
            student_stats[speaker]["total_messages"] += 1
            relevancy_str = row.get("lesson_relevancy", "").strip()
            if relevancy_str:
                try:
                    relevancy = float(relevancy_str)
                    student_stats[speaker]["lesson_relevancy_sum"] += relevancy
                    student_stats[speaker]["relevancy_count"] += 1
                except ValueError:
                    pass
            assigned = row.get("assigned_category", "").strip().lower()
            if assigned:
                cats = [cat.strip() for cat in assigned.split(",")]
                for cat in cats:
                    if cat in categories:
                        student_stats[speaker][cat] += 1
    for student, stats in student_stats.items():
        if stats["relevancy_count"] > 0:
            stats["avg_lesson_relevancy"] = stats["lesson_relevancy_sum"] / stats["relevancy_count"]
        else:
            stats["avg_lesson_relevancy"] = 0.0
    return student_stats, categories


def write_aggregate_to_csv(aggregate_data, categories, output):
    """
    Write the aggregated engagement metrics to CSV.
    
    'output' can be a file path or a file-like object.
    """
    fieldnames = ["student", "total_messages", "avg_lesson_relevancy"] + categories
    rows = []
    for student, stats in aggregate_data.items():
        row = {
            "student": student,
            "total_messages": stats["total_messages"],
            "avg_lesson_relevancy": stats["avg_lesson_relevancy"]
        }
        for cat in categories:
            row[cat] = stats[cat]
        rows.append(row)
    if hasattr(output, "write"):
        writer = csv.DictWriter(output, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(rows)
    else:
        with open(output, "w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(rows)


# ---------- CLI for Testing ----------

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description="Aggregate engagement metrics from a parsed CSV file and a roster file."
    )
    parser.add_argument("--input_csv", required=True, help="Path to the parsed CSV file.")
    parser.add_argument("--roster", required=True, help="Path to the roster file (one student per line).")
    parser.add_argument("--output_csv", required=True, help="Path to output aggregated CSV file.")
    args = parser.parse_args()
    aggregate_data, categories = aggregate_engagement(args.input_csv, args.roster)
    write_aggregate_to_csv(aggregate_data, categories, args.output_csv)
    print(f"Aggregated engagement metrics written to {args.output_csv}")
